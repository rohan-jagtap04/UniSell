{"ast":null,"code":"/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst {\n  FileCoverage\n} = require('./file-coverage');\n\nconst {\n  CoverageSummary\n} = require('./coverage-summary');\n\nfunction maybeConstruct(obj, klass) {\n  if (obj instanceof klass) {\n    return obj;\n  }\n\n  return new klass(obj);\n}\n\nfunction loadMap(source) {\n  const data = Object.create(null);\n\n  if (!source) {\n    return data;\n  }\n\n  Object.entries(source).forEach(_ref => {\n    let [k, cov] = _ref;\n    data[k] = maybeConstruct(cov, FileCoverage);\n  });\n  return data;\n}\n/** CoverageMap is a map of `FileCoverage` objects keyed by file paths. */\n\n\nclass CoverageMap {\n  /**\n   * @constructor\n   * @param {Object} [obj=undefined] obj A coverage map from which to initialize this\n   * map's contents. This can be the raw global coverage object.\n   */\n  constructor(obj) {\n    if (obj instanceof CoverageMap) {\n      this.data = obj.data;\n    } else {\n      this.data = loadMap(obj);\n    }\n  }\n  /**\n   * merges a second coverage map into this one\n   * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged\n   *  correctly for the same files and additional file coverage keys are created\n   *  as needed.\n   */\n\n\n  merge(obj) {\n    const other = maybeConstruct(obj, CoverageMap);\n    Object.values(other.data).forEach(fc => {\n      this.addFileCoverage(fc);\n    });\n  }\n  /**\n   * filter the coveragemap based on the callback provided\n   * @param {Function (filename)} callback - Returns true if the path\n   *  should be included in the coveragemap. False if it should be\n   *  removed.\n   */\n\n\n  filter(callback) {\n    Object.keys(this.data).forEach(k => {\n      if (!callback(k)) {\n        delete this.data[k];\n      }\n    });\n  }\n  /**\n   * returns a JSON-serializable POJO for this coverage map\n   * @returns {Object}\n   */\n\n\n  toJSON() {\n    return this.data;\n  }\n  /**\n   * returns an array for file paths for which this map has coverage\n   * @returns {Array{string}} - array of files\n   */\n\n\n  files() {\n    return Object.keys(this.data);\n  }\n  /**\n   * returns the file coverage for the specified file.\n   * @param {String} file\n   * @returns {FileCoverage}\n   */\n\n\n  fileCoverageFor(file) {\n    const fc = this.data[file];\n\n    if (!fc) {\n      throw new Error(`No file coverage available for: ${file}`);\n    }\n\n    return fc;\n  }\n  /**\n   * adds a file coverage object to this map. If the path for the object,\n   * already exists in the map, it is merged with the existing coverage\n   * otherwise a new key is added to the map.\n   * @param {FileCoverage} fc the file coverage to add\n   */\n\n\n  addFileCoverage(fc) {\n    const cov = new FileCoverage(fc);\n    const {\n      path\n    } = cov;\n\n    if (this.data[path]) {\n      this.data[path].merge(cov);\n    } else {\n      this.data[path] = cov;\n    }\n  }\n  /**\n   * returns the coverage summary for all the file coverage objects in this map.\n   * @returns {CoverageSummary}\n   */\n\n\n  getCoverageSummary() {\n    const ret = new CoverageSummary();\n    Object.values(this.data).forEach(fc => {\n      ret.merge(fc.toSummary());\n    });\n    return ret;\n  }\n\n}\n\nmodule.exports = {\n  CoverageMap\n};","map":{"version":3,"names":["FileCoverage","require","CoverageSummary","maybeConstruct","obj","klass","loadMap","source","data","Object","create","entries","forEach","k","cov","CoverageMap","constructor","merge","other","values","fc","addFileCoverage","filter","callback","keys","toJSON","files","fileCoverageFor","file","Error","path","getCoverageSummary","ret","toSummary","module","exports"],"sources":["/Users/baccha/Desktop/UniSell/node_modules/istanbul-lib-coverage/lib/coverage-map.js"],"sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst { FileCoverage } = require('./file-coverage');\nconst { CoverageSummary } = require('./coverage-summary');\n\nfunction maybeConstruct(obj, klass) {\n    if (obj instanceof klass) {\n        return obj;\n    }\n\n    return new klass(obj);\n}\n\nfunction loadMap(source) {\n    const data = Object.create(null);\n    if (!source) {\n        return data;\n    }\n\n    Object.entries(source).forEach(([k, cov]) => {\n        data[k] = maybeConstruct(cov, FileCoverage);\n    });\n\n    return data;\n}\n\n/** CoverageMap is a map of `FileCoverage` objects keyed by file paths. */\nclass CoverageMap {\n    /**\n     * @constructor\n     * @param {Object} [obj=undefined] obj A coverage map from which to initialize this\n     * map's contents. This can be the raw global coverage object.\n     */\n    constructor(obj) {\n        if (obj instanceof CoverageMap) {\n            this.data = obj.data;\n        } else {\n            this.data = loadMap(obj);\n        }\n    }\n\n    /**\n     * merges a second coverage map into this one\n     * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged\n     *  correctly for the same files and additional file coverage keys are created\n     *  as needed.\n     */\n    merge(obj) {\n        const other = maybeConstruct(obj, CoverageMap);\n        Object.values(other.data).forEach(fc => {\n            this.addFileCoverage(fc);\n        });\n    }\n\n    /**\n     * filter the coveragemap based on the callback provided\n     * @param {Function (filename)} callback - Returns true if the path\n     *  should be included in the coveragemap. False if it should be\n     *  removed.\n     */\n    filter(callback) {\n        Object.keys(this.data).forEach(k => {\n            if (!callback(k)) {\n                delete this.data[k];\n            }\n        });\n    }\n\n    /**\n     * returns a JSON-serializable POJO for this coverage map\n     * @returns {Object}\n     */\n    toJSON() {\n        return this.data;\n    }\n\n    /**\n     * returns an array for file paths for which this map has coverage\n     * @returns {Array{string}} - array of files\n     */\n    files() {\n        return Object.keys(this.data);\n    }\n\n    /**\n     * returns the file coverage for the specified file.\n     * @param {String} file\n     * @returns {FileCoverage}\n     */\n    fileCoverageFor(file) {\n        const fc = this.data[file];\n        if (!fc) {\n            throw new Error(`No file coverage available for: ${file}`);\n        }\n        return fc;\n    }\n\n    /**\n     * adds a file coverage object to this map. If the path for the object,\n     * already exists in the map, it is merged with the existing coverage\n     * otherwise a new key is added to the map.\n     * @param {FileCoverage} fc the file coverage to add\n     */\n    addFileCoverage(fc) {\n        const cov = new FileCoverage(fc);\n        const { path } = cov;\n        if (this.data[path]) {\n            this.data[path].merge(cov);\n        } else {\n            this.data[path] = cov;\n        }\n    }\n\n    /**\n     * returns the coverage summary for all the file coverage objects in this map.\n     * @returns {CoverageSummary}\n     */\n    getCoverageSummary() {\n        const ret = new CoverageSummary();\n        Object.values(this.data).forEach(fc => {\n            ret.merge(fc.toSummary());\n        });\n\n        return ret;\n    }\n}\n\nmodule.exports = {\n    CoverageMap\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}